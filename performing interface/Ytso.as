/*  * PROJECT: AR Instrument * http://ytsoar.googlecode.com/ * Copyright 2010 Google Inc * -------------------------------------------------------------------------------- * This work complements FLARManager, developed by Eric Socolofsky * http://transmote.com/flar * FLARManager is Copyright 2009, Eric Socolofsky * * This work also complements FLARToolkit, developed by Saqoosha as part of the Libspark project. * http://www.libspark.org/wiki/saqoosha/FLARToolKit * FLARToolkit is Copyright (C)2008 Saqoosha, * and is ported from NYARToolkit, which is ported from ARToolkit.* * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with this framework; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  */ package{	import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;		//import flash.net.SharedObject;    //import flash.net.SharedObjectFlushStatus;	import flash.media.Camera;	import fl.controls.Slider;	import fl.events.SliderEvent;	import com.ytso.NoteScale;	import com.ytso.ISoundFilePlayer;	import com.ytso.ExternalSoundFilePlayer;	import com.ytso.EmbeddedSoundFilePlayer;	import com.ytso.Ribbon;	//import com.ytso.Recorder;	import com.ytso.LocalizationManager;	import com.ytso.NoteBar; //jjs	import com.ytso.LoadingBar;	import com.ytso.RibbonHead;	//FLAR AR classes	import com.transmote.flar.utils.threshold.DrunkHistogramThresholdAdapter;	import com.transmote.flar.utils.threshold.IntegralImageThresholdAdapter;	import com.transmote.flar.utils.threshold.DrunkWalkThresholdAdapter;	import com.transmote.flar.utils.threshold.HistogramThresholdAdapter;	import com.transmote.flar.utils.threshold.logicalThresholdAdapter;	import com.transmote.flar.utils.smoother.FLARMatrixSmoother_Average;	import com.transmote.flar.FLARManager;	import com.transmote.flar.marker.FLARMarkerEvent;	import com.transmote.utils.time.FramerateDisplay;	import com.ytso.LoadingVeil;	import flash.net.*;	public class Ytso extends MovieClip {									//		//		// App lifecycle:		//		// The app has several phases in its lifecycle:		//		//		init 1. Start loading localization text		//		init 2. Wait for completion		//		init 3. start loading sounds		//		init 4. Wait for completion		//		init 5. initialize the UI		//	      |		//	      |		//        v		//		practice (loop): User plays with the app, but no calls to recorder.record()		//		record (loop): starts when user hits record button; same as practice, but with calls to recorder.recod()		//	      |		//	      |		//        v		//		save 1. starts when user hits stop record button; recorder starts sending the recording to the server		//		save 2. wait for completion		//		save 3. save done, redirect entire page to playback.jsp		//				public static const TEMPO_MAX_THEORETICAL:int = 2000;		public static const TEMPO_MAX_USER:int = 1880;						private var ribbonHead:RibbonHead = new RibbonHead();				private var slider:Slider;		private var video:Sprite;		private var flarManager:FLARManager;				private var loadingBar:LoadingBar = new LoadingBar(false);				//private var recorder:Recorder = new Recorder();				private var l8n:LocalizationManager;				private var scaleTargetX:Number = 0;		private var scaleTargetNoteHintWidth:Number = 20;		private var scale:NoteScale = new NoteScale(9, 500, .20, 375, 700, 35, 0xffffff);		//private var scale:NoteScale = new NoteScale(9, 500, .20, stage.stageHeight, 40, 3, 20, 0xffffff);		private var hitTolerence:Number = 10;				private var ribbon1:Ribbon;		private var ribbon2:Ribbon;		private var ribbon3:Ribbon;				private var currentNoteSet:int = 0; //what music set to play				private var markerCorners:Vector.<Point> = new Vector.<Point>();				private var markerCover:Sprite = new Sprite();		private var coverColor:uint = 0xffffff;		private var coverAlpha:Number = 1;		private var step:Number;				//Used to detect/reject accidental repeat notes		private var hitListPoints:Vector.<Point> = new Vector.<Point>;		private var hitListTime:Vector.<Number> = new Vector.<Number>;		private var hitlistMax:Number = 4;		private var hitlistDistanceTolerence:Number = 20;		private var hitlistTimeTolerence:Number = 100;				private var loadingVeil:LoadingVeil;				private var lastPosition:Point = new Point(0,0);				private var time:Number = getTimer(); 				private var recordingButton:Sprite = new Sprite();				var logicalThreshold:logicalThresholdAdapter = new logicalThresholdAdapter(3,75,50);		private var sfPlayer:ISoundFilePlayer = null;				var markerOnStage:Boolean = true;				var debug_trace = false;				private var keyIsDown:Array = new Array(200);				private var initialized:Boolean = false;						public function Ytso():void {			//do everything after we've been added to the stage			this.flarManager = new FLARManager("resources/flar/flarConfig.xml"); //FLARManager xml config file															/*			var sharedObject:SharedObject = SharedObject.getLocal( "ytso", "/" );						if( sharedObject.data.cameraIndex ){				trace('{CAMERA INIT} -- Found previous camera data');								var cameraIndex:int = sharedObject.data.cameraIndex;				var cameras:String = sharedObject.data.cameraHash;								trace('{CAMERA INIT} -- their list: ' + Camera.names);				trace('{CAMERA INIT} -- our list  : ' + cameras);												var sameList:Boolean = true;																if(cameras == Camera.names.join(" | ") ){					trace('{CAMERA INIT} -- Camera list match');					trace('{CAMERA INIT} -- Trying to use: ' + cameraIndex);					//this.flarManager.flarCameraSource.cameraIndex = cameraIndex;				}else{					trace('{CAMERA INIT} -- No camera list match');					trace('{CAMERA INIT} -- Going to try to scan cameras');				}								}else{				trace('{CAMERA INIT} -- no camera shared object - Going to try to scan cameras');			}			*/											this.addEventListener(Event.ADDED_TO_STAGE, addedToStage, false, 0, true);		}				public function addedToStage(e:Event) {		//////////////////////////////////////////////////////////////////////////////////////////////		// And.... GO!		//////////////////////////////////////////////////////////////////////////////////////////////					//trace("# Lifecycle phase: INIT 1");						this.addChild(loadingBar);			loadingBar.progress = 0;						//set up event handlers before AR init			var lang:String = loaderInfo.parameters.hasOwnProperty("lang") ? loaderInfo.parameters.lang : "";			l8n = new LocalizationManager(lang);			l8n.addEventListener(Event.COMPLETE, onl8nComplete, false, 0 ,true);			l8n.addEventListener(IOErrorEvent.IO_ERROR, onl8nError, false, 0, true);			l8n.addEventListener(IOErrorEvent.NETWORK_ERROR, onl8nError, false, 0, true);			l8n.load();			//trace("# Lifecycle phase: INIT 2");			// will wait for completion until onl8nComplete or onl8nError are called			// (see below)			//		}		public function onl8nError(e:IOErrorEvent) {			//trace("I/O Error when initializing LocalizationManager: "+e);			initSoundFilePlayer();		}		public function onl8nComplete(e:Event) {			loadingBar.progress = .1;			//trace("LocalizationManager ready");			initSoundFilePlayer();		}						private function initSoundFilePlayer() {		//////////////////////////////////////////////////////////////////////////////////////////////		// sets up the sfPlayer with event listeners, etc.		//////////////////////////////////////////////////////////////////////////////////////////////				//trace("# Lifecycle phase: INIT 3");			if (this.sfPlayer != null) return; //prevent multiple initializations			this.sfPlayer = new ExternalSoundFilePlayer();			//this.sfPlayer = new EmbeddedSoundFilePlayer();			this.sfPlayer.addEventListener(Event.COMPLETE, onSFPlayerComplete, false, 0 ,true);			this.sfPlayer.addEventListener(ProgressEvent.PROGRESS, onSFPlayerProgress, false, 0 ,true);			this.sfPlayer.addEventListener(IOErrorEvent.IO_ERROR, onSFPlayerError, false, 0, true);			this.sfPlayer.addEventListener(IOErrorEvent.NETWORK_ERROR, onSFPlayerError, false, 0, true);			this.sfPlayer.load();						//			//trace("# Lifecycle phase: INIT 4");			// will wait for completion until onSFPlayerComplete or onSFPlayerError are called			// (see below)			//					}		public function onSFPlayerProgress(e:ProgressEvent) {			//trace("onSFPlayerProgress: "+e.bytesLoaded+" of "+e.bytesTotal);						loadingBar.progress = (e.bytesLoaded/ e.bytesTotal) * .8 + .2;					}		public function onSFPlayerError(e:IOErrorEvent) {			//trace("onSFPlayerError: "+e);			initUI();		}		public function onSFPlayerComplete(e:Event) {			//trace("onSFPlayerComplete");						this.removeChild(loadingBar);			loadingBar = null;			initUI();		}						private function initUI():void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Add the scale to the screen, add the ribbon, start every frame aniimation		// Init FLAR Manager and start video / Marker tracker		//////////////////////////////////////////////////////////////////////////////////////////////				//trace("# Lifecycle phase: INIT 5");						if (this.initialized == true) return; //prevent multiple initializations			this.initialized = true;						//loadingVeil = new LoadingVeil();			//this.addChild(loadingVeil);			//loadingVeil.show();			//removeLoadingVeil(null); //temporary fix						//add event listener for the recorder			//recorder.addEventListener(IOErrorEvent.IO_ERROR, onRecorderSaveError, false, 0, true);			//recorder.addEventListener(ProgressEvent.PROGRESS, onRecorderSaveProgress, false, 0, true);			//recorder.addEventListener(Event.COMPLETE, onRecorderSaveComplete, false, 0, true);			this.videoScreen.addChild(markerCover);						ribbon1 = new Ribbon(6,0x00ADEE,1,true, 50);			ribbon1.prefill(-20,-20);			this.videoScreen.addChild(ribbon1);						ribbon2 = new Ribbon(6,0xFFDD15,1,true, 50);			ribbon2.prefill(-20,-20);			this.videoScreen.addChild(ribbon2);						ribbon3 = new Ribbon(6,0x652D90,1,true, 50);			ribbon3.prefill(-20,-20);			this.videoScreen.addChild(ribbon3);						this.videoScreen.addChild(ribbonHead);						this.videoScreen.addChild(scale);						scale.y = 65;			scaleTargetX = stage.stageWidth/2 - scale.width/2;			scaleTargetNoteHintWidth = 20;						this.stage.addEventListener(Event.ENTER_FRAME, onFrame);						this.flarManager.addEventListener(ErrorEvent.ERROR, this.onFlarManagerError); //FLARManager handle errors						// add FLARManager.flarSource to the display list to display the video capture.			video = Sprite(this.flarManager.flarSource);			this.flarManager.flarCameraSource.addEventListener("cameraInited", removeLoadingVeil);			this.addChild(video);			setChildIndex(video, 0);			//video.alpha = .5;									// begin listening for FLARMarkerEvents.			this.flarManager.addEventListener(FLARMarkerEvent.MARKER_UPDATED, this.onMarkerUpdated);						//framerate display helps to keep an eye on performance.			//var framerateDisplay:FramerateDisplay = new FramerateDisplay();			//this.addChild(framerateDisplay);			//framerateDisplay.y = stage.stageHeight - 25;			//framerateDisplay.x = 300;						//FLAR Config			this.flarManager.markerExtrapolation = true;			this.flarManager.markerRemovalDelay = 30;			this.flarManager.markerUpdateThreshold = 150;			this.flarManager.mirrorDisplay = true;			this.flarManager.smoothing = 0;			//this.flarManager.adaptiveSmoothingCenter = 4;			//this.flarManager.smoother = new FLARMatrixSmoother_Average();						this.flarManager.threshold = 80;						//this.flarManager.thresholdSourceDisplay = true;			//this.flarManager.thresholdAdapter = new DrunkHistogramThresholdAdapter();			//this.flarManager.thresholdAdapter = new IntegralImageThresholdAdapter();			//this.flarManager.thresholdAdapter = new DrunkWalkThresholdAdapter();			//this.flarManager.thresholdAdapter = new HistogramThresholdAdapter(); //***** SEEMS REALLY GOOD			this.flarManager.thresholdAdapter = logicalThreshold; //Adam's version of threshold adapter						scale.addStrummingBar(stage.stageWidth/2); //jjs			setupTempo();						//Record button as well as not selector buttons			recordButton.addEventListener(MouseEvent.CLICK,toggleRecording);			note1Select.addEventListener(MouseEvent.CLICK, function(){selectNoteSet(0);});			note2Select.addEventListener(MouseEvent.CLICK, function(){selectNoteSet(1);});			note3Select.addEventListener(MouseEvent.CLICK, function(){selectNoteSet(2);});			volumeControl.addEventListener(MouseEvent.CLICK,toggleAudio);						recordButton.addEventListener(MouseEvent.MOUSE_OVER, recordHover);			recordButton.addEventListener(MouseEvent.MOUSE_OUT, recordHoverOff);						volumeControl.addEventListener(MouseEvent.CLICK, toggleAudio);			volumeControl.addEventListener(MouseEvent.MOUSE_OVER, volumeHover);			volumeControl.addEventListener(MouseEvent.MOUSE_OUT, volumeHoverOff);			step = 1 / flarManager.markerRemovalDelay;						//add handlers for keyboard			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyPressed, false, 0, true);			stage.addEventListener(KeyboardEvent.KEY_UP, keyReleased, false, 0, true);			//trace("# Lifecycle phase: PRACTICE");					}				private function selectNoteSet(num:int) {		////////////////////////////////////////////////		// change the currently selected note set (the set of sounds that is played)		////////////////////////////////////////////////			currentNoteSet = num;			noteSelector.gotoAndStop(num + 1);		}				private function triggerNote() {		////////////////////////////////////////////////		// force triggering a note		////////////////////////////////////////////////			this.barWasHit(Math.max(0, Math.round(scale.barVector.length / 2) - 1), ribbon1.lastPoint, lastPosition);		}				private function removeLoadingVeil(e:Event){			//trace('camera loaded');			//this.removeChild(loadingVeil);			//loadingVeil = null;		}						private function onFlarManagerError (evt:ErrorEvent):void {		//////////////////////////////////////////////////////////////////////////////////////////////		//If there is an error in the Flar system		//////////////////////////////////////////////////////////////////////////////////////////////			this.flarManager.removeEventListener(ErrorEvent.ERROR, this.onFlarManagerError);			this.flarManager.removeEventListener(FLARMarkerEvent.MARKER_ADDED, this.onMarkerAdded);			this.flarManager.removeEventListener(FLARMarkerEvent.MARKER_UPDATED, this.onMarkerUpdated);			this.flarManager.removeEventListener(FLARMarkerEvent.MARKER_REMOVED, this.onMarkerRemoved);						if (debug_trace) trace(evt.text);		}								private function onMarkerAdded (evt:FLARMarkerEvent):void {		//////////////////////////////////////////////////////////////////////////////////////////////		//Marker has come on screen.		//////////////////////////////////////////////////////////////////////////////////////////////						}								private function onMarkerUpdated (evt:FLARMarkerEvent):void {		//////////////////////////////////////////////////////////////////////////////////////////////		//Marker has been updated, make chnages		//////////////////////////////////////////////////////////////////////////////////////////////			logicalThreshold.used(this.flarManager.threshold );						markerOnStage = true;			var newPoint = new Point(evt.marker.x, evt.marker.y)						ribbon1.addPoint(newPoint);			ribbon2.addPoint(new Point (newPoint.x, newPoint.y - 6));			ribbon3.addPoint(new Point (newPoint.x, newPoint.y + 6));						markerCorners = evt.marker.corners;		}								private function onMarkerRemoved (evt:FLARMarkerEvent):void {		//////////////////////////////////////////////////////////////////////////////////////////////		//marker has been removed		//////////////////////////////////////////////////////////////////////////////////////////////					}				private function onFrame(e:Event):void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Check if the marker placed a new point in the vector since last frame - if not, att new point same as last point		// Draw the ribbons		// Move the vertacle scale markers		//////////////////////////////////////////////////////////////////////////////////////////////				var hit:Boolean = checkForHits(ribbon1.lastPoint, lastPosition);			//note: all data type/precision conversion is now done interally to the Recorder class, just pass the Point as-is			//if(!hit) recorder.record(new Point(ribbon1.lastPoint.x, (ribbon1.lastPoint.y - scale.y)), getTimer(), false, currentNoteSet); //no note recorded, record position if needed			//if(recorder.recording) recordingTime.text = recorder.recordingTime; //Show recording time length if recording						//threshold.text = 'threshold: '+String(this.flarManager.threshold); //For testing purposes						if(!markerOnStage){ //marker off stage continue the smoothing - needs a new point, just give it clone of last point recorded				ribbon1.addPoint(ribbon1.lastPoint);				ribbon2.addPoint(ribbon2.lastPoint);				ribbon3.addPoint(ribbon3.lastPoint);				fadeMarkerOut(); //marker not tracked, fade out			}else{				fadeMarkerIn(); //marker is tracked, fade in			}						ribbonHead.x = ribbon1.lastPoint.x;			ribbonHead.y = ribbon1.lastPoint.y;						//drawMarkerCover(); //Draws box around the marker			markerOnStage = false; //Set so that we can see if the marker updates before this runs again						ribbon1.draw(2);			ribbon2.draw(4);			ribbon3.draw(6);									var index:int = scale.returnIndexFromY(ribbon1.lastPoint.y - scale.y);			scale.highlightLine(index);									if (scale.strumming || scale.paused) {				scale.moveDots(); //jjs			} else {				if (!scale.strumming) scale.move(getTimer()); //jjs			}						lastPosition = ribbon1.lastPoint;		}								private function drawMarkerCover():void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Draw the bounding box around the marker		//////////////////////////////////////////////////////////////////////////////////////////////						if(markerCorners.length < 4) return;						markerCover.graphics.clear();			markerCover.graphics.lineStyle(1, coverColor, (1 * coverAlpha));			markerCover.graphics.beginFill(coverColor, (.75 * coverAlpha));			markerCover.graphics.moveTo(markerCorners[3].x, markerCorners[3].y);						//loop through points			for(var i:int = 0; i < markerCorners.length; i++) {				markerCover.graphics.lineTo(markerCorners[i].x, markerCorners[i].y);			}						markerCover.graphics.endFill();		}								private function checkForHits(pos:Point, lastPos:Point):Boolean{		//////////////////////////////////////////////////////////////////////////////////////////////		// Check to see if the ribbon has hit any bars		// Check both a tolerance hit - did the ribbon come within x px from a bar		//Also see if between this and the last frame, if the ribbon crossed a bar that should have resulted in a note being played (sub frame checking)		//////////////////////////////////////////////////////////////////////////////////////////////							//No need to check, the ribbon is out of the scale bounds, or the marker has been off stage too long			if(pos.y < scale.y || pos.y > scale.y + scale.setHeight || coverAlpha <= 0) return false;			for(var i:int = 0; i< scale.barVector.length; i++){					//check to see if the bar was hit between this and the last frame					if (markerCrossedBar(pos, scale.barVector[i])){//jjs						return barWasHit(i, pos, lastPos);					}			}					return false;				}				private function barWasHit(i:int, pos:Point, lastPos:Point):Boolean {		//////////////////////////////////////////////////////////////////////////////////////////////		// Called when a particular bar is hit by the marker		// i is an index in barVector		//////////////////////////////////////////////////////////////////////////////////////////////				var yHit:Number = interpolateHitY(scale.location(scale.barVector[i]).x, pos, lastPos);						if(yHit < scale.y || yHit > scale.y + scale.setHeight) return false; //Escape if the interpolated point is outside the note scale						var hitLocation:Point = new Point(pos.x, yHit);					scale.addDot(scale.barVector[i], yHit - scale.y);			if (debug_trace) trace('calculated hit at: '+yHit);						var index:int = scale.returnIndexFromY(yHit - scale.y)			sfPlayer.play(index, currentNoteSet);			//note: all data type/precision conversion is now done interally to the Recorder class, just pass the Point as-is						//recorder.record(new Point(hitLocation.x, (hitLocation.y - scale.y)), getTimer(), true, currentNoteSet);						recordHit(hitLocation, getTimer());			return true;		}		public function keyPressed(e:KeyboardEvent) {		//////////////////////////////////////////////////////////////////////////////////////////////		// handle keyboard input - keys down		//////////////////////////////////////////////////////////////////////////////////////////////							switch (e.keyCode) {				case 32:					//space bar - trigger note					if (!this.keyIsDown[e.keyCode]) triggerNote();					break; 									case 48:					//0 key - toggle tempo pause/unpause					if (!this.keyIsDown[e.keyCode]) this.scale.paused = !this.scale.paused;					break; 									default:					//key 1-9 select a note set. if shift, then also trigger a note in the new set					if ((e.keyCode >= 49) && (e.keyCode <= 57)) {						var setNum:int = e.keyCode - 49;						if ((setNum >= 0) && (setNum < sfPlayer.numSets)) {							selectNoteSet(e.keyCode - 49);							if (e.shiftKey) triggerNote();						}					}			}						this.keyIsDown[e.keyCode] = true;		} //keyPressed						public function keyReleased(e:KeyboardEvent) {		//////////////////////////////////////////////////////////////////////////////////////////////		// handle keyboard input - keys up		//////////////////////////////////////////////////////////////////////////////////////////////							this.keyIsDown[e.keyCode] = false;		} //keyReleased						public function toggleRecording(e:MouseEvent){		//////////////////////////////////////////////////////////////////////////////////////////////		// if recording, stop. If not, start.		//////////////////////////////////////////////////////////////////////////////////////////////										return; //Need to configure a server to make this work						/*			if(recorder.recording){								this.removeChild(slider);				var viel:LoadingVeil = new LoadingVeil();				this.addChild(viel);				viel.show();								//this.removeChild(video);				this.flarManager.removeEventListener(ErrorEvent.ERROR, this.onFlarManagerError);				this.flarManager.removeEventListener(FLARMarkerEvent.MARKER_UPDATED, this.onMarkerUpdated);								this.flarManager.deactivate();				this.flarManager.dispose();								//Remove event listeners for all UI elements				this.stage.removeEventListener(Event.ENTER_FRAME, onFrame);				recordButton.removeEventListener(MouseEvent.CLICK,toggleRecording);				volumeControl.removeEventListener(MouseEvent.CLICK,toggleAudio);				recordButton.removeEventListener(MouseEvent.MOUSE_OVER, recordHover);				recordButton.removeEventListener(MouseEvent.MOUSE_OUT, recordHoverOff);				volumeControl.removeEventListener(MouseEvent.CLICK, toggleAudio);				volumeControl.removeEventListener(MouseEvent.MOUSE_OVER, volumeHover);				volumeControl.removeEventListener(MouseEvent.MOUSE_OUT, volumeHoverOff);				stage.removeEventListener(KeyboardEvent.KEY_DOWN, keyPressed);				stage.removeEventListener(KeyboardEvent.KEY_UP, keyReleased);								//trace("# Lifecycle phase: SAVE 1");				recorder.stop();				//trace("# Lifecycle phase: SAVE 2");				recordButton.gotoAndStop(2);			}else{				//trace("# Lifecycle phase: RECORD");				ribbonHead.recordingVersion();				recorder.start();				recordButton.gotoAndStop(4);			}			*/					}				private function onRecorderSaveError(e:IOErrorEvent) {		//////////////////////////////////////////////////////////////////////////////////////////////		//If there is an error when saving the recording		//////////////////////////////////////////////////////////////////////////////////////////////			//trace("I/O Error when saving recording: "+e);			//TODO - show error message or attempt to re-save?		}				private function onRecorderSaveProgress(e:ProgressEvent) {		//////////////////////////////////////////////////////////////////////////////////////////////		//When there is progress made saving the recording		//(may or may not actually be called, depending on on length of recording)		//////////////////////////////////////////////////////////////////////////////////////////////			//trace("Saving recording progress");			//TODO - update progress bar		}				private function onRecorderSaveComplete(e:Event) {		//////////////////////////////////////////////////////////////////////////////////////////////		//When saving of the recording is complete		//////////////////////////////////////////////////////////////////////////////////////////////			//trace("# Lifecycle phase: SAVE 3");						//trace("onRecorderSaveComplete");			//TODO - redirect to 															//var url:String = "playback.jsp?shareHash="+escape(recorder.shareHash)+"&new=1&lang="+l8n.fullLang;			//var request:URLRequest = new URLRequest(url);			//navigateToURL(request, "_self");					}						public function toggleAudio(e:MouseEvent){		//////////////////////////////////////////////////////////////////////////////////////////////		// if mute, un mute, and vise versa		//////////////////////////////////////////////////////////////////////////////////////////////										if(sfPlayer.muted){				sfPlayer.unmute();				volumeControl.gotoAndStop(2);			}else{				sfPlayer.mute();				volumeControl.gotoAndStop(4);			}		}				private function recordHover(e:MouseEvent){			/*			if(recorder.recording){				recordButton.gotoAndStop(4);			}else{				recordButton.gotoAndStop(2);			}			*/		}				private function recordHoverOff(e:MouseEvent){			/*			if(recorder.recording){				recordButton.gotoAndStop(3);			}else{				recordButton.gotoAndStop(1);			}			*/		}				private function volumeHover(e:MouseEvent){			if(sfPlayer.muted){				volumeControl.gotoAndStop(4);			}else{				volumeControl.gotoAndStop(2);			}		}				private function volumeHoverOff(e:MouseEvent){			if(sfPlayer.muted){				volumeControl.gotoAndStop(3);			}else{				volumeControl.gotoAndStop(1);			}		}								private function recordHit(point:Point, time:Number):void{		//////////////////////////////////////////////////////////////////////////////////////////////		// record position, and time of bar strike		// Only keep hold of "hitListTime" of them		//////////////////////////////////////////////////////////////////////////////////////////////				//trace(point);						hitListPoints.push(point);			hitListTime.push(time);						if(hitListPoints.length > hitlistMax){				hitListPoints.shift();				hitListTime.shift();			}		}								private function interpolateHitY( Lx:Number, A:Point, B:Point):Number{		//////////////////////////////////////////////////////////////////////////////////////////////		// Return where a verticle line intersects a line-segment (between p1 and p2)		// Used to cacluate where a note should have been played between frames		//////////////////////////////////////////////////////////////////////////////////////////////					//return A.y + ((B.y-A.y)/(B.x-A.x))*(Lx-A.x);			return B.y;		}								private function betweenXPoints(checkPoint:Point, point1:Point, point2:Point){		//////////////////////////////////////////////////////////////////////////////////////////////		// Check to see if the x of a point is between the x of 2 points		// used to know if a point was hit between frames		//////////////////////////////////////////////////////////////////////////////////////////////					if(point1.x <= point2.x){				if((checkPoint.x > point1.x && checkPoint.x < point2.x) || (checkPoint.x == point1.x || checkPoint.x == point2.x) ) return true;			}else{				if((checkPoint.x < point1.x && checkPoint.x > point2.x) || (checkPoint.x == point1.x || checkPoint.x == point2.x) ) return true;			}						return false;		}						private function markerCrossedBar(markerLoc, bar:NoteBar){ //jjs		//////////////////////////////////////////////////////////////////////////////////////////////		// Check to see if the marker is on a different side of the bar than the last time this check was performed on this bar		// used to know if a point was hit between frames		//////////////////////////////////////////////////////////////////////////////////////////////					return bar.markerDidCross(markerLoc);		}						private function setupTempo(){		//////////////////////////////////////////////////////////////////////////////////////////////		// Setup the tempo slider		// note that you will need a slider component in the fla's library for this to compile		//////////////////////////////////////////////////////////////////////////////////////////////					slider = new Slider();//instantiate slider 						slider.width = 503;			slider.move(185, 41 - slider.height - 15); //position slider			slider.liveDragging = true; // control if slider updates instantly or after mouse is released			slider.setSize(503,0);//set size of slider			slider.maximum = Ytso.TEMPO_MAX_USER;//set maximum value			slider.value = Ytso.TEMPO_MAX_USER / 4;//set mininum value			slider.minimum = 0;			slider.tickInterval = 100;//set tick position interval, you do not have to set this			slider.addEventListener(SliderEvent.CHANGE, handleSliderChange);// this is a listener that broadcasts evertime an event changes						this.addChild(slider);			updateTempoFromSlider(slider);		}								public function handleSliderChange(e:SliderEvent):void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Please fill in		//////////////////////////////////////////////////////////////////////////////////////////////					updateTempoFromSlider(e.target as Slider);		}								private function updateTempoFromSlider(slider:Slider):void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Plese fill in		//////////////////////////////////////////////////////////////////////////////////////////////						if (slider.value > 0){				if (slider.value < slider.tickInterval) slider.value = slider.tickInterval; //make the slider "snap" away from the strump position				startMovingBars();				scale.addNewBars = true;				scale.strumming = false;				scale.frequency = Ytso.TEMPO_MAX_THEORETICAL - slider.value;				scaleTargetX = 0; //setting scaleTargetX instead of scale.x will cause the enter frame handler to tween the x position of the scale rather than making it jump				scaleTargetNoteHintWidth = stage.stageWidth;				scale.paused = false;				//trace(slider.value);			}else{				scale.addNewBars = false;				scale.strumming = true;				scale.clearBarVector();				scaleTargetX = stage.stageWidth/2 - 10; //setting scaleTargetX instead of scale.x will cause the enter frame handler to tween the x position of the scale rather than making it jump				scaleTargetNoteHintWidth = 20;				scale.addStrummingBar(0); //jjs			}		}								private function startMovingBars():void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Start animation of bars		//////////////////////////////////////////////////////////////////////////////////////////////					scale.addNewBars = true;		}								private function fadeMarkerOut():void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Fade the marker out		//////////////////////////////////////////////////////////////////////////////////////////////						if(coverAlpha == 0) return;			coverAlpha -= step;						if(coverAlpha <= 0) coverAlpha = 0;						ribbonHead.alpha = coverAlpha;			ribbon1.alpha = coverAlpha;			ribbon2.alpha = coverAlpha;			ribbon3.alpha = coverAlpha;					}								private function fadeMarkerIn():void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Fade the marker cover back in		//////////////////////////////////////////////////////////////////////////////////////////////						if(coverAlpha == 1) return;						coverAlpha += step * 2;						if(coverAlpha >= 1) coverAlpha = 1;						ribbonHead.alpha = coverAlpha;			ribbon1.alpha = coverAlpha;			ribbon2.alpha = coverAlpha;			ribbon3.alpha = coverAlpha;					}					}	}