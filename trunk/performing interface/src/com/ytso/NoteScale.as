/*  * PROJECT: AR Instrument * http://ytsoar.googlecode.com/ * Copyright 2010 Google Inc * -------------------------------------------------------------------------------- * This work complements FLARManager, developed by Eric Socolofsky * http://transmote.com/flar * FLARManager is Copyright 2009, Eric Socolofsky * * This work also complements FLARToolkit, developed by Saqoosha as part of the Libspark project. * http://www.libspark.org/wiki/saqoosha/FLARToolKit * FLARToolkit is Copyright (C)2008 Saqoosha, * and is ported from NYARToolkit, which is ported from ARToolkit.* * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with this framework; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  */package com.ytso{			import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;	import flash.filters.*;		import com.ytso.NoteDot;	import com.ytso.NoteBar;	import com.ytso.ScaleBar;		public class NoteScale extends MovieClip {		private var _scaleThickness:Number;		private var _lines:Number;		private var _width:Number;		private var _height:Number;		private var _barColor:uint;		private var _speed:Number;		private var _frequency:Number;				private var sinceLastBar:Number = 0;				private var _barVector:Vector.<Sprite> = new Vector.<Sprite>(); //Vector to hold the verticle bars - gets looped through - faster than array		private var _lineVector:Vector.<ScaleBar> = new Vector.<ScaleBar>(); //Vector to hold the horizantal lines		private var _playBackDots:Vector.<NoteDot> = new Vector.<NoteDot>(); //Vector to hold the horizantal lines		private var time:Number = 0;				var debug_trace = false;				private var _paused:Boolean = false;				public var addNewBars = false;		public var strumming = true;		public function NoteScale(lines:Number = 5, frequency:Number = 1000, speed:Number = .32, height:Number = 200, width:Number = 700, scaleThickness:Number = 3, barColor:uint = 0xffffff, activeColor:uint = 0xffffff, activeAplha:Number = .25){			_lines = lines;			_speed = speed;			_width = width;			_height = height;			_barColor = barColor;			_scaleThickness = scaleThickness;			_frequency = frequency;						init(activeColor, activeAplha);		}				private function init(activeColor, activeAplha):void{		//////////////////////////////////////////////////////////////////////////////////////////////		//Build the horizantal scale		//////////////////////////////////////////////////////////////////////////////////////////////									var spacter:Number  = (_height - (_scaleThickness * _lines)) / (_lines +1);			for (var i:Number = 0; i< _lines; i++){				_lineVector[i] = new ScaleBar(_scaleThickness, 700, false, activeColor, activeAplha);				_lineVector[i].y = i * (spacter + _scaleThickness);				this.addChild(_lineVector[i]);			}									/*			for (var i:Number = 0; i< _lines; i++){				_lineVector[i] = new ScaleBar(_scaleThickness, 700, false);												_lineVector[i].y = _height/(_lines -1) * i;				this.addChild(_lineVector[i]);			}			*/		}						public function set frequency(frequency:Number){		//////////////////////////////////////////////////////////////////////////////////////////////		//Set the frequency		//////////////////////////////////////////////////////////////////////////////////////////////			_frequency = frequency;		}				public function addBar(offset = 0){		//////////////////////////////////////////////////////////////////////////////////////////////		//Create a new vericle bar put into the barVector vector for easy handeling		//////////////////////////////////////////////////////////////////////////////////////////////			if (this._paused) return;						var length:int = barVector.length;									barVector[length] = new NoteBar();						/*			barVector[length]  = new Sprite();			barVector[length].graphics.lineStyle(_barThickness, _barColor);			barVector[length].graphics.moveTo(0,0);			barVector[length].graphics.lineTo(0, _height);			*/						barVector[length].x = _width;			this.addChild(barVector[length]);						var move:Number = offset * _speed;			barVector[length].x -= move; //shift over x pixels					}				public function addStrummingBar(x:Number){ //jjs		//////////////////////////////////////////////////////////////////////////////////////////////		//Create a new vericle bar put into the barVector vector for easy handeling		//////////////////////////////////////////////////////////////////////////////////////////////			clearBarVector();			var length:int = barVector.length;						barVector[length] = new NoteBar();			barVector[length].x = 350;			this.addChild(barVector[length]);						strumming = true;		}			public function clearBarVector(){						for each(var bar:Sprite in _barVector){				if(contains(bar)) removeChild(bar);				bar = null;			}						_barVector = new Vector.<Sprite>();		}				public function removeStrummingBar(){ //jjs		//////////////////////////////////////////////////////////////////////////////////////////////		//Create a new vericle bar put into the barVector vector for easy handeling		//////////////////////////////////////////////////////////////////////////////////////////////			var length:int = barVector.length;			this.removeChild(barVector[length]);						barVector[length]  = null;						//var move:Number = offset * _speed;			//barVector[length].x -= move; //shift over x pixels			strumming = false;					}								public function highlightLine(index:int):void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Change the color of a bar to indicate what note will be played		//////////////////////////////////////////////////////////////////////////////////////////////					index = (_lines -1) - index;						for (var i:Number = 0; i< _lines; i++){				if(i == index){					_lineVector[i].makeActive();				}else{					_lineVector[i].makeNormal();				}			}											}				public function addDot(bar:Sprite, yPos:Number):void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Add a marker where the bar was hit		//////////////////////////////////////////////////////////////////////////////////////////////				if(!strumming){				if (_paused) {					addDotInSpace(new Point(bar.x + bar.width/2, yPos));				} else {					var dot:NoteDot = new NoteDot();					bar.addChild(dot);					dot.y = yPos;				}			}else{				addDotInSpace(new Point(bar.x + bar.width/2, yPos));							}		}						public function addDotInSpace(pos:Point):void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Add a marker where the bar was hit - for replay animation		//////////////////////////////////////////////////////////////////////////////////////////////				var index:int = _playBackDots.length;						_playBackDots[index] = new NoteDot();			this.addChild(_playBackDots[index]);			_playBackDots[index].x = pos.x;			_playBackDots[index].y = pos.y;					}				public function moveDots(){		//////////////////////////////////////////////////////////////////////////////////////////////		// update all the bars, animate them to the left "speed"px		//////////////////////////////////////////////////////////////////////////////////////////////						//clean up empty array cells after child removed			//splicing while in move loop cause out of order issues. sprites didnt always move exactly in order, studdered on sibling remove			for(var i:Number = 0; i< _playBackDots.length; i++){				if(!contains(_playBackDots[i])) _playBackDots.splice(i, 1);			}						for each(var dot:Sprite in _playBackDots){				//off of stage? if so - remove it				if(location(dot).x < 0){					if(contains(dot)) removeChild(dot);				}else{					dot.x -= 10; //shift over x pixels				}			}		}						public function move(stageTime, tempo = 1){		//////////////////////////////////////////////////////////////////////////////////////////////		// update all the bars, animate them to the left "speed"px		//////////////////////////////////////////////////////////////////////////////////////////////			//trace(barVector.length);												var gap:Number = stageTime - time;			time = stageTime;			var move:Number = gap * _speed * tempo;								for(var i:Number = 0; i< barVector.length; i++){				if(!contains(barVector[i])) barVector.splice(i, 1);			}						for each(var bar:Sprite in barVector){								if(location(bar).x < 0){					if(contains(bar)) this.removeChild(bar);				}else{					if (!this._paused) bar.x -= move; //shift over x pixels				}			}									if(time - sinceLastBar >= _frequency / tempo){				var offset:Number = (time - sinceLastBar) - _frequency;				sinceLastBar = time;				if (debug_trace) trace('vertical bar timer offset'+offset);				addBar(offset);			}						if (debug_trace) trace(time - getTimer());													}				public function set paused(v:Boolean):void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Pause or unpause moving bars		//////////////////////////////////////////////////////////////////////////////////////////////			this._paused = v;		}		public function get paused():Boolean {		//////////////////////////////////////////////////////////////////////////////////////////////		// Return whether or not bar motion is paused		//////////////////////////////////////////////////////////////////////////////////////////////			return this._paused;		}				public function get barVector(){		//////////////////////////////////////////////////////////////////////////////////////////////		// Return the vector holding the bars		//////////////////////////////////////////////////////////////////////////////////////////////			return _barVector;		}						public function returnIndexFromY(y):int{		//////////////////////////////////////////////////////////////////////////////////////////////		// Find the note to play based on the y position		//////////////////////////////////////////////////////////////////////////////////////////////												var index:Number = Math.floor(((_height - y) / _height) * _lines);						if(index > _lines -1){				return _lines -1;			}else if(index < 0){				return 0;			}									return index;		}				public function get setHeight(){		//////////////////////////////////////////////////////////////////////////////////////////////		// Return the set height of the scale, not the actual height		//////////////////////////////////////////////////////////////////////////////////////////////				return _height;		}				public function location(bar:Sprite):Point{		//////////////////////////////////////////////////////////////////////////////////////////////		// Return the local position of a bar		//////////////////////////////////////////////////////////////////////////////////////////////				return bar.localToGlobal( new Point() );		}						}	}