/*  * PROJECT: AR Instrument * http://ytsoar.googlecode.com/ * Copyright 2010 Google Inc * -------------------------------------------------------------------------------- * This work complements FLARManager, developed by Eric Socolofsky * http://transmote.com/flar * FLARManager is Copyright 2009, Eric Socolofsky * * This work also complements FLARToolkit, developed by Saqoosha as part of the Libspark project. * http://www.libspark.org/wiki/saqoosha/FLARToolKit * FLARToolkit is Copyright (C)2008 Saqoosha, * and is ported from NYARToolkit, which is ported from ARToolkit.* * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. *  * You should have received a copy of the GNU General Public License * along with this framework; if not, write to the Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA *  */package com.ytso{		import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;			public class Ribbon extends MovieClip {		public static const HIT:String = "hit";				private var _thickness:int;		private var _color:uint;		private var _opacity:Number;		private var _smooth:Boolean;		private var _length:int;		private var _gravity:Boolean;		private var _offset:Number;		private var _speed:Number;				private var _useSecret:Boolean = false;				private var q:Number = 0;		private var inertia:Number;		private var inertiaVector:Vector.<Number> = new Vector.<Number>(4);				private var _lastPoint:Point = new Point(0,0);				private var ribbonContainer:Vector.<Point> = new Vector.<Point>(); //hold positions of Ribbon bits				private var ribbonLine:Sprite = new Sprite(); //The ribbon				public function Ribbon(thickness:int = 3, color:uint = 0xff0000, opacity:Number = .5, smooth:Boolean = true, length:int = 100, gravity = false, offset:Number = 0) {		//////////////////////////////////////////////////////////////////////////////////////////////		// Add the ribbon		//////////////////////////////////////////////////////////////////////////////////////////////					_thickness = thickness;			_color = color;			_opacity = opacity;			_smooth = smooth;			_length = length;			_gravity = gravity;			_offset = offset;						this.addChild(ribbonLine);		}				public function prefill(x:int, y:int){		//////////////////////////////////////////////////////////////////////////////////////////////		// Prefill the ribbon vector with points		//////////////////////////////////////////////////////////////////////////////////////////////					for(var i:int = 0; i < _length; i++){				ribbonContainer.push(new Point(x, y)); //push new point into vector			}					}				public function addPoint(newPoint:Point){		//////////////////////////////////////////////////////////////////////////////////////////////		// Add new point to the ribbon		// Rerurn class for chaining		//////////////////////////////////////////////////////////////////////////////////////////////						newPoint = new Point(newPoint.x, newPoint.y + _offset);									_lastPoint = newPoint.clone();						ribbonContainer.push(newPoint); //push new point into vector			return this;		}						public function draw2(speed:int = 10){		//////////////////////////////////////////////////////////////////////////////////////////////		// Draw the ribbon with smoothing is stated		// Rerurn class for chaining		//////////////////////////////////////////////////////////////////////////////////////////////																	limitVector(ribbonContainer, _length);						if(_smooth) ribbonContainer = smoothPoints(ribbonContainer); //smooth the points in the ribbonContainer						ribbonLine.graphics.clear(); //clear last drawing			ribbonLine.graphics.lineStyle(_thickness, _color, _opacity,false,"normal",CapsStyle.SQUARE);						ribbonLine.graphics.moveTo(ribbonContainer[0].x, ribbonContainer[0].y);						var op:Number = -4;			var gravity:Number = ribbonContainer.length;			var length:Number = ribbonContainer.length;												for(var i:int; i< length; i++) {				//Draw to next point								//op += .05;				gravity = (_gravity)? gravity --: 0;								//ribbonLine.graphics.lineStyle(_thickness, _color, op,false,"normal",CapsStyle.NONE);				ribbonLine.graphics.lineTo(ribbonContainer[i].x, ribbonContainer[i].y);				//Move point left "speed" px				ribbonContainer[i].offset(-1 * speed, gravity);			}									return this;		}						public function secret(state:Boolean){			trace("Shhhh!");			_useSecret = state;		}							public function draw3(speed:int = 10){		//////////////////////////////////////////////////////////////////////////////////////////////		// Draw the ribbon with smoothing is stated		// Rerurn class for chaining		//////////////////////////////////////////////////////////////////////////////////////////////											limitVector(ribbonContainer, _length);						//if(_smooth) 						if(_useSecret){				ribbonContainer = smoothPointsSECRET(ribbonContainer); //smooth the points in the ribbonContainer			}else{				ribbonContainer = smoothPoints(ribbonContainer); //smooth the points in the ribbonContainer			}						ribbonLine.graphics.clear(); //clear last drawing			ribbonLine.graphics.lineStyle(6, _color, _opacity,false,"normal",CapsStyle.SQUARE);						ribbonLine.graphics.moveTo(ribbonContainer[0].x, ribbonContainer[0].y);						var op:Number = -4;			var gravity:Number = ribbonContainer.length;			var length:Number = ribbonContainer.length;												for(var i:int; i< length; i++) {				//Draw to next point								//op += .05;				gravity = (_gravity)? gravity --: 0;								//ribbonLine.graphics.lineStyle(_thickness, _color, op,false,"normal",CapsStyle.NONE);				//ribbonLine.graphics.lineTo(ribbonContainer[i].x, ribbonContainer[i].y);								if(i > 20){										var test:Point = Point.interpolate(ribbonContainer[i], ribbonContainer[i-5], .5);					//test.offset(5,5);									ribbonContainer[i].offset(5,5);															ribbonLine.graphics.curveTo(ribbonContainer[i].x, ribbonContainer[i].y,test.x, test.y); 				}else{					ribbonLine.graphics.lineTo(ribbonContainer[i].x, ribbonContainer[i].y);									}																				//Move point left "speed" px				ribbonContainer[i].offset(-1 * speed, gravity);			}									return this;		}															public function draw(speed:int = 10){		//////////////////////////////////////////////////////////////////////////////////////////////		// Draw the ribbon with smoothing is stated		// Rerurn class for chaining		//////////////////////////////////////////////////////////////////////////////////////////////											_speed = speed;						limitVector(ribbonContainer, _length);									if(_useSecret){				ribbonContainer = smoothPointsSECRET(ribbonContainer); //smooth the points in the ribbonContainer SECRET STYLE!!!			}else{				ribbonContainer = smoothPoints(ribbonContainer); //smooth the points in the ribbonContainer			}									//if(_smooth) ribbonContainer = smoothPoints(ribbonContainer); //smooth the points in the ribbonContainer									ribbonLine.graphics.clear(); //clear last drawing			ribbonLine.graphics.beginFill(_color, _opacity);			ribbonLine.graphics.moveTo(ribbonContainer[0].x, ribbonContainer[0].y);						var op:Number = -4;			var gravity:Number = ribbonContainer.length;			var length:Number = ribbonContainer.length;												for(var i:int = 0; i< length; i++) {				//Draw to next point								//op += .05;												//ribbonLine.graphics.lineStyle(_thickness, _color, op,false,"normal",CapsStyle.NONE);				ribbonLine.graphics.lineTo(ribbonContainer[i].x, ribbonContainer[i].y);			}									for(var i:int = length - 1; i > 0; i--) {								ribbonLine.graphics.lineTo(ribbonContainer[i].x +10, ribbonContainer[i].y +10);			}						ribbonLine.graphics.endFill();												return this;		}						private function limitVector(vector:Vector.<Point>, max:uint){		//////////////////////////////////////////////////////////////////////////////////////////////		// Limit the length of a vector		//////////////////////////////////////////////////////////////////////////////////////////////				while(vector.length > max){				vector.shift();			}		}						private function smoothPointsSECRET(points:Vector.<Point>):Vector.<Point>{		//////////////////////////////////////////////////////////////////////////////////////////////		// Take the vector of points and smooth/normalize them with an averaging algorythm		// Adapted from motiondraw.com's lang simplification 		//////////////////////////////////////////////////////////////////////////////////////////////			var coef:Number = Math.random();						var newPoints:Vector.<Point> = new Vector.<Point>;			var vectorLength = points.length;									if(vectorLength < 5) return points; //Do not smmoth under 5 points						for(var i:int = 0; i < vectorLength; i++){				if(i == vectorLength - 1 || i == vectorLength - 2 || i == 1 || i == 0){										newPoints[i] = new Point(points[i].x, points[i].y);								}else{					var averageX:Number = 0;					var averageY:Number = 0;										for(var j:int = 4; j > -1; j--){						averageX += points[i+2-j].x;						averageY += points[i+2-j].y;					}										averageX = averageX/5; //find average					averageY = averageY/5; //find average										var sinOffset:Number =  40* Math.sin(i*2);										newPoints[i] = newPoints[i] = new Point((points[i].x + averageX)/2 - _speed, (points[i].y + averageY)/2 + sinOffset);				}							}						return newPoints;		}								private function smoothPoints(points:Vector.<Point>):Vector.<Point>{		//////////////////////////////////////////////////////////////////////////////////////////////		// Take the vector of points and smooth/normalize them with an averaging algorythm		// Adapted from motiondraw.com's lang simplification 		//////////////////////////////////////////////////////////////////////////////////////////////			q += .6;									var coef:Number = Math.random();						var newPoints:Vector.<Point> = new Vector.<Point>;			var vectorLength = points.length;						inertiaVector.push(Point.distance(points[vectorLength-1], points[vectorLength-2]));			if(inertiaVector.length > 4) inertiaVector.shift();			inertia = (inertiaVector[0] + inertiaVector[1] + inertiaVector[2] + inertiaVector[3]) /4;						if(vectorLength < 5) return points; //Do not smmoth under 5 points						for(var i:int = 0; i < vectorLength; i++){				if(i == vectorLength - 1 || i == vectorLength - 2 || i == 1 || i == 0){										newPoints[i] = new Point(points[i].x, points[i].y);								}else{					var averageX:Number = 0;					var averageY:Number = 0;										for(var j:int = 4; j > -1; j--){						averageX += points[i+2-j].x;						averageY += points[i+2-j].y;					}										averageX = averageX/5; //find average					averageY = averageY/5; //find average										var sinOffset:Number =  (i / vectorLength) * (inertia* Math.sin((i - q) /4) + inertia);										newPoints[i] = newPoints[i] = new Point((points[i].x + averageX)/2 - _speed, (points[i].y + averageY)/2 + sinOffset);				}							}						return newPoints;		}						public function get lastPoint():Point{		//////////////////////////////////////////////////////////////////////////////////////////////		// Return the position of the last point		//////////////////////////////////////////////////////////////////////////////////////////////			return _lastPoint;		}									}	}