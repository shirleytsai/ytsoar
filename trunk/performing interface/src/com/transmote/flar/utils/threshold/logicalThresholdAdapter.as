package com.transmote.flar.utils.threshold {	import flash.display.BitmapData;		public class logicalThresholdAdapter implements IThresholdAdapter {		private static const MIN_VARIANCE:Number = 5;		private static const MAX_VARIANCE:Number = 50;				private var _speed:Number;		private var _range:Number;		private var _usedContainer:Vector.<Number> = new Vector.<Number>();		private var _sampleLength:int = 100;		private var reset:Boolean = true;		private var lastUsed:Number;		private var step:int;				private var adaptiveThresholdingStep:Number = MIN_VARIANCE;						public function logicalThresholdAdapter (speed:Number=1, range:Number=100, sampleLength:Number = 100) {		//////////////////////////////////////////////////////////////////////////////////////////////		// Init and setup vars		//////////////////////////////////////////////////////////////////////////////////////////////					_speed = speed;			_range = range;			_sampleLength = sampleLength;			init();					}				private function init():void{		//////////////////////////////////////////////////////////////////////////////////////////////		// Preload the average with 100s		//////////////////////////////////////////////////////////////////////////////////////////////					for(var i:int = 0; i < _sampleLength; i++){				_usedContainer[i] = 100;			}		}								public function initFromXML (paramsObj:Object) :void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Im not using xml		//////////////////////////////////////////////////////////////////////////////////////////////							}				public function calculateThreshold (source:BitmapData, currentThreshold:Number) :Number {		//////////////////////////////////////////////////////////////////////////////////////////////		// Return a new threshold		// This is based on a best-guess dumb-search		//////////////////////////////////////////////////////////////////////////////////////////////									var average:Number = averageUsed();			var newThreshold:Number;						if(reset == true){				reset = false;				return lastUsed;			}						step ++;			//trace(step);						if(step > _range) step = 0;						if(step%2 == 0){				newThreshold = average + step/2;			}else{				newThreshold = average - (step/2 +1);			}												return newThreshold;		}		public function used(value:Number){		//////////////////////////////////////////////////////////////////////////////////////////////		// Record this threshold value because it was known to work		//////////////////////////////////////////////////////////////////////////////////////////////							lastUsed = value;			_usedContainer.push(value);			if(_usedContainer.length >= _sampleLength) _usedContainer.shift();						step = 0;			reset = true;		}				public function averageUsed(){		//////////////////////////////////////////////////////////////////////////////////////////////		// Average the known good threshold values		//////////////////////////////////////////////////////////////////////////////////////////////								var length:int = _usedContainer.length;			var average:Number = 0;						for(var i:int = 0; i < length; i++){				average += _usedContainer[i];			}			average = average/length;						//no need to go above or below a value that would cause a search above 255 or below 0.			if(average > 255 - _range/2){				average = 255 - _range/2;			}else if(average < _range/2){				average = _range/2			}						return average;		}		public function resetCalculations (currentThreshold:Number) :void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Not sure		//////////////////////////////////////////////////////////////////////////////////////////////					this.adaptiveThresholdingStep = MIN_VARIANCE;		}				public function dispose () :void {		//////////////////////////////////////////////////////////////////////////////////////////////		// Not sure		//////////////////////////////////////////////////////////////////////////////////////////////				}				public function get runsEveryFrame () :Boolean {		//////////////////////////////////////////////////////////////////////////////////////////////		// Run the threshold adapter even when no marker is found?		//////////////////////////////////////////////////////////////////////////////////////////////					return false;		}			}}